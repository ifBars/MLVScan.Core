using FluentAssertions;
using MLVScan.Models;
using MLVScan.Services;
using Xunit;
using Xunit.Abstractions;
using Xunit.Sdk;

namespace MLVScan.Core.Tests.Integration;

/// <summary>
/// Integration tests that scan confirmed malware samples from the QUARANTINE folder.
/// These samples are real-world malware from Nexus posing as legitimate mods.
/// 
/// IMPORTANT: These files should NEVER be executed - static analysis only!
/// </summary>
public class QuarantineMalwareScanTests
{
    private readonly ITestOutputHelper _output;
    private readonly string? _quarantineFolder;

    public QuarantineMalwareScanTests(ITestOutputHelper output)
    {
        _output = output;
        _quarantineFolder = FindQuarantineFolder();
    }

    private static string? FindQuarantineFolder()
    {
        var currentDir = Directory.GetCurrentDirectory();

        while (currentDir != null)
        {
            var quarantinePath = Path.Combine(currentDir, "QUARANTINE");
            if (Directory.Exists(quarantinePath))
            {
                return quarantinePath;
            }

            var mlvScanCorePath = Path.Combine(currentDir, "MLVScan.Core", "QUARANTINE");
            if (Directory.Exists(mlvScanCorePath))
            {
                return mlvScanCorePath;
            }

            var parent = Directory.GetParent(currentDir);
            currentDir = parent?.FullName;
        }

        return null;
    }

    private string GetSamplePath(string filename)
    {
        Skip.If(_quarantineFolder == null, "QUARANTINE folder not found. This test requires malware samples which are not available in CI.");

        var path = Path.Combine(_quarantineFolder, filename);
        Skip.IfNot(File.Exists(path), $"Sample {filename} not found in QUARANTINE folder.");

        return path;
    }

    private void LogFindings(List<ScanFinding> findings, string sampleName)
    {
        _output.WriteLine($"=== {sampleName} ===");
        _output.WriteLine($"Total findings: {findings.Count}");
        _output.WriteLine("");

        foreach (var finding in findings)
        {
            _output.WriteLine($"[{finding.Severity}] {finding.RuleId}");
            _output.WriteLine($"  Location: {finding.Location}");
            _output.WriteLine($"  Description: {finding.Description}");
            if (finding.HasCallChain)
            {
                _output.WriteLine($"  Attack Path:");
                foreach (var node in finding.CallChain!.Nodes)
                {
                    _output.WriteLine($"    {node}");
                }
            }
            _output.WriteLine("");
        }
    }

    #region NoMoreTrash.dll.di Tests

    /// <summary>
    /// NoMoreTrash uses shell32.dll ShellExecuteEx hidden in a Southwards class,
    /// called from OnInitializeMelon. Tests call chain consolidation.
    /// </summary>
    [SkippableFact]
    public void Scan_NoMoreTrash_ShouldDetectShell32PInvoke()
    {
        // Skip if QUARANTINE not available (CI environment)
        var path = GetSamplePath("NoMoreTrash.dll.di");

        // Arrange
        var scanner = new AssemblyScanner(RuleFactory.CreateDefaultRules());

        // Act
        var findings = scanner.Scan(path).ToList();
        LogFindings(findings, "NoMoreTrash.dll.di");

        // Assert
        findings.Should().NotBeEmpty();

        var shell32Findings = findings.Where(f =>
            f.Description.Contains("shell32", StringComparison.OrdinalIgnoreCase) ||
            f.Description.Contains("ShellExecute", StringComparison.OrdinalIgnoreCase)).ToList();

        shell32Findings.Should().NotBeEmpty("Should detect shell32.dll P/Invoke");
        shell32Findings.Should().AllSatisfy(f => f.Severity.Should().BeOneOf(Severity.High, Severity.Critical));
    }

    [SkippableFact]
    public void Scan_NoMoreTrash_ShouldConsolidateIntoSingleFinding()
    {
        // Skip if QUARANTINE not available (CI environment)
        var path = GetSamplePath("NoMoreTrash.dll.di");

        // Arrange
        var scanner = new AssemblyScanner(RuleFactory.CreateDefaultRules());

        // Act
        var findings = scanner.Scan(path).ToList();

        // Assert - should be exactly 1 consolidated finding for the shell32 attack
        var shell32Findings = findings.Where(f =>
            f.RuleId == "DllImportRule" &&
            f.Description.Contains("shell32", StringComparison.OrdinalIgnoreCase)).ToList();

        shell32Findings.Should().HaveCount(1,
            "P/Invoke declaration and call site should be consolidated into a single finding");
    }

    [SkippableFact]
    public void Scan_NoMoreTrash_ConsolidatedFindingShouldHaveCallChain()
    {
        // Skip if QUARANTINE not available (CI environment)
        var path = GetSamplePath("NoMoreTrash.dll.di");

        // Arrange
        var scanner = new AssemblyScanner(RuleFactory.CreateDefaultRules());

        // Act
        var findings = scanner.Scan(path).ToList();

        // Assert
        var shell32Finding = findings.FirstOrDefault(f =>
            f.RuleId == "DllImportRule" &&
            f.Description.Contains("shell32", StringComparison.OrdinalIgnoreCase));

        shell32Finding.Should().NotBeNull();
        shell32Finding!.HasCallChain.Should().BeTrue("Finding should include call chain");
        shell32Finding.CallChain!.Nodes.Should().HaveCountGreaterThanOrEqualTo(2,
            "Call chain should have at least entry point and declaration");

        // Verify the call chain structure
        var entryPoints = shell32Finding.CallChain.Nodes
            .Where(n => n.NodeType == CallChainNodeType.EntryPoint).ToList();
        var declarations = shell32Finding.CallChain.Nodes
            .Where(n => n.NodeType == CallChainNodeType.SuspiciousDeclaration).ToList();

        entryPoints.Should().NotBeEmpty("Should identify OnInitializeMelon as entry point");
        declarations.Should().NotBeEmpty("Should identify Southwards.ShellExecuteEx as declaration");
    }

    [SkippableFact]
    public void Scan_NoMoreTrash_CallChainShouldShowAttackPath()
    {
        // Skip if QUARANTINE not available (CI environment)
        var path = GetSamplePath("NoMoreTrash.dll.di");

        // Arrange
        var scanner = new AssemblyScanner(RuleFactory.CreateDefaultRules());

        // Act
        var findings = scanner.Scan(path).ToList();

        // Assert
        var shell32Finding = findings.First(f =>
            f.RuleId == "DllImportRule" &&
            f.Description.Contains("shell32", StringComparison.OrdinalIgnoreCase));

        // Description should mention both the hidden location and the caller
        shell32Finding.Description.Should().Contain("Southwards",
            "Should mention the class hiding the P/Invoke");
        shell32Finding.Description.Should().Contain("OnInitializeMelon",
            "Should mention the entry point that calls the malicious code");
    }

    #endregion

    #region CustomTV_IL2CPP.dll.di Tests

    [SkippableFact]
    public void Scan_CustomTV_IL2CPP_ShouldDetectMaliciousPatterns()
    {
        // Skip if QUARANTINE not available (CI environment)
        var path = GetSamplePath("CustomTV_IL2CPP.dll.di");

        // Arrange
        var scanner = new AssemblyScanner(RuleFactory.CreateDefaultRules());

        // Act
        var findings = scanner.Scan(path).ToList();
        LogFindings(findings, "CustomTV_IL2CPP.dll.di");

        // Assert - should detect something malicious
        findings.Should().NotBeEmpty("CustomTV_IL2CPP is confirmed malware");

        var highSeverity = findings.Where(f => f.Severity >= Severity.High).ToList();
        highSeverity.Should().NotBeEmpty("Should have high-severity findings for confirmed malware");
    }

    #endregion

    #region EndlessGraffiti.dll.di Tests

    [SkippableFact]
    public void Scan_EndlessGraffiti_ShouldDetectMaliciousPatterns()
    {
        // Skip if QUARANTINE not available (CI environment)
        var path = GetSamplePath("EndlessGraffiti.dll.di");

        // Arrange
        var scanner = new AssemblyScanner(RuleFactory.CreateDefaultRules());

        // Act
        var findings = scanner.Scan(path).ToList();
        LogFindings(findings, "EndlessGraffiti.dll.di");

        // Assert
        findings.Should().NotBeEmpty("EndlessGraffiti is confirmed malware");

        var highSeverity = findings.Where(f => f.Severity >= Severity.High).ToList();
        highSeverity.Should().NotBeEmpty("Should have high-severity findings for confirmed malware");
    }

    #endregion

    #region RealRadio.dll.di Tests

    [SkippableFact]
    public void Scan_RealRadio_ShouldDetectMaliciousPatterns()
    {
        // Skip if QUARANTINE not available (CI environment)
        var path = GetSamplePath("RealRadio.dll.di");

        // Arrange
        var scanner = new AssemblyScanner(RuleFactory.CreateDefaultRules());

        // Act
        var findings = scanner.Scan(path).ToList();
        LogFindings(findings, "RealRadio.dll.di");

        // Assert
        findings.Should().NotBeEmpty("RealRadio is confirmed malware");

        var highSeverity = findings.Where(f => f.Severity >= Severity.High).ToList();
        highSeverity.Should().NotBeEmpty("Should have high-severity findings for confirmed malware");
    }

    [SkippableFact]
    public void Scan_RealRadio_DllImportFindingShouldIncludeInvocationContext()
    {
        var path = GetSamplePath("RealRadio.dll.di");

        var scanner = new AssemblyScanner(RuleFactory.CreateDefaultRules());

        var findings = scanner.Scan(path).ToList();
        var dllImportFinding = findings.FirstOrDefault(f => f.RuleId == "DllImportRule");

        dllImportFinding.Should().NotBeNull();
        dllImportFinding!.Description.Should().Contain("Invocation context:");
        dllImportFinding.Description.Should().Contain("lpFile");
        dllImportFinding.Description.Should().Contain("%TEMP%/<guid>.cmd");
        dllImportFinding.Description.Should().NotContain("<dynamic via Box>");
        dllImportFinding.Description.Should().ContainEquivalentOf("embedded resource");
    }

    #endregion

    #region S1API.Il2Cpp.MelonLoader.dll.di Tests

    [SkippableFact]
    public void Scan_S1API_Il2Cpp_MelonLoader_ShouldDetectMaliciousPatterns()
    {
        // Skip if QUARANTINE not available (CI environment)
        var path = GetSamplePath("S1API.Il2Cpp.MelonLoader.dll.di");

        // Arrange
        var scanner = new AssemblyScanner(RuleFactory.CreateDefaultRules());

        // Act
        var findings = scanner.Scan(path).ToList();
        LogFindings(findings, "S1API.Il2Cpp.MelonLoader.dll.di");

        // Assert
        findings.Should().NotBeEmpty("S1API.Il2Cpp.MelonLoader is confirmed malware");

        var highSeverity = findings.Where(f => f.Severity >= Severity.High).ToList();
        highSeverity.Should().NotBeEmpty("Should have high-severity findings for confirmed malware");
    }

    #endregion

    #region ScheduleIMoreNpcs.dll.di Tests

    [SkippableFact]
    public void Scan_ScheduleIMoreNpcs_ShouldDetectMaliciousPatterns()
    {
        // Skip if QUARANTINE not available (CI environment)
        var path = GetSamplePath("ScheduleIMoreNpcs.dll.di");

        // Arrange
        var scanner = new AssemblyScanner(RuleFactory.CreateDefaultRules());

        // Act
        var findings = scanner.Scan(path).ToList();
        LogFindings(findings, "ScheduleIMoreNpcs.dll.di");

        // Assert
        findings.Should().NotBeEmpty("ScheduleIMoreNpcs is confirmed malware");

        var highSeverity = findings.Where(f => f.Severity >= Severity.High).ToList();
        highSeverity.Should().NotBeEmpty("Should have high-severity findings for confirmed malware");
    }

    #endregion

    #region All Samples Summary Tests

    [SkippableTheory]
    [InlineData("NoMoreTrash.dll.di")]
    [InlineData("CustomTV_IL2CPP.dll.di")]
    [InlineData("EndlessGraffiti.dll.di")]
    [InlineData("RealRadio.dll.di")]
    [InlineData("S1API.Il2Cpp.MelonLoader.dll.di")]
    [InlineData("ScheduleIMoreNpcs.dll.di")]
    public void Scan_AllQuarantineSamples_ShouldProduceFindings(string filename)
    {
        // Skip if QUARANTINE not available (CI environment)
        var path = GetSamplePath(filename);

        // Arrange
        var scanner = new AssemblyScanner(RuleFactory.CreateDefaultRules());

        // Act
        var findings = scanner.Scan(path).ToList();

        // Assert - all quarantine samples are confirmed malware and should produce findings
        findings.Should().NotBeEmpty($"{filename} is confirmed malware and should produce findings");
    }

    [SkippableTheory]
    [InlineData("NoMoreTrash.dll.di")]
    [InlineData("CustomTV_IL2CPP.dll.di")]
    [InlineData("EndlessGraffiti.dll.di")]
    [InlineData("RealRadio.dll.di")]
    [InlineData("S1API.Il2Cpp.MelonLoader.dll.di")]
    [InlineData("ScheduleIMoreNpcs.dll.di")]
    public void Scan_AllQuarantineSamples_ShouldHaveHighOrCriticalSeverity(string filename)
    {
        // Skip if QUARANTINE not available (CI environment)
        var path = GetSamplePath(filename);

        // Arrange
        var scanner = new AssemblyScanner(RuleFactory.CreateDefaultRules());

        // Act
        var findings = scanner.Scan(path).ToList();

        // Assert
        var highSeverity = findings.Where(f => f.Severity >= Severity.High).ToList();
        highSeverity.Should().NotBeEmpty(
            $"{filename} is confirmed malware and should have High or Critical severity findings");
    }

    /// <summary>
    /// Comprehensive test that scans all samples and outputs a summary.
    /// </summary>
    [SkippableFact]
    public void Scan_AllQuarantineSamples_SummaryReport()
    {
        // Skip if QUARANTINE not available (CI environment)
        Skip.If(_quarantineFolder == null, "QUARANTINE folder not found. This test requires malware samples which are not available in CI.");

        var samples = new[]
        {
            "NoMoreTrash.dll.di",
            "CustomTV_IL2CPP.dll.di",
            "EndlessGraffiti.dll.di",
            "RealRadio.dll.di",
            "S1API.Il2Cpp.MelonLoader.dll.di",
            "ScheduleIMoreNpcs.dll.di"
        };

        var scanner = new AssemblyScanner(RuleFactory.CreateDefaultRules());
        var results = new List<(string Sample, int TotalFindings, int HighSeverity, int Critical, List<string> RulesTriggered)>();

        foreach (var sample in samples)
        {
            var path = Path.Combine(_quarantineFolder!, sample);
            if (!File.Exists(path))
            {
                _output.WriteLine($"SKIP: {sample} not found");
                continue;
            }

            var findings = scanner.Scan(path).ToList();
            var rulesTriggered = findings
                .Where(f => f.RuleId != null)
                .Select(f => f.RuleId!)
                .Distinct()
                .ToList();

            results.Add((
                sample,
                findings.Count,
                findings.Count(f => f.Severity >= Severity.High),
                findings.Count(f => f.Severity == Severity.Critical),
                rulesTriggered
            ));
        }

        // Output summary
        _output.WriteLine("=== QUARANTINE SCAN SUMMARY ===");
        _output.WriteLine("");
        _output.WriteLine("| Sample | Total | High+ | Critical | Rules Triggered |");
        _output.WriteLine("|--------|-------|-------|----------|-----------------|");

        foreach (var (sample, total, high, critical, rules) in results)
        {
            var rulesStr = string.Join(", ", rules.Take(3));
            if (rules.Count > 3)
                rulesStr += $" (+{rules.Count - 3})";
            _output.WriteLine($"| {sample,-30} | {total,5} | {high,5} | {critical,8} | {rulesStr} |");
        }

        // All samples should have detections
        results.Should().AllSatisfy(r =>
            r.TotalFindings.Should().BeGreaterThan(0, $"{r.Sample} should have findings"));

        results.Should().AllSatisfy(r =>
            r.HighSeverity.Should().BeGreaterThan(0, $"{r.Sample} should have high-severity findings"));
    }

    #endregion

    #region Call Chain Consolidation Verification

    /// <summary>
    /// Verifies that when call chain consolidation is working, we don't get
    /// duplicate findings for the same attack pattern.
    /// </summary>
    [SkippableFact]
    public void Scan_NoMoreTrash_NoDuplicateFindingsForSameAttack()
    {
        // Skip if QUARANTINE not available (CI environment)
        var path = GetSamplePath("NoMoreTrash.dll.di");

        // Arrange
        var scanner = new AssemblyScanner(RuleFactory.CreateDefaultRules());

        // Act
        var findings = scanner.Scan(path).ToList();

        // Group by RuleId
        var groupedByRule = findings
            .Where(f => f.RuleId != null)
            .GroupBy(f => f.RuleId)
            .ToList();

        foreach (var group in groupedByRule)
        {
            _output.WriteLine($"Rule {group.Key}: {group.Count()} findings");
            foreach (var f in group)
            {
                _output.WriteLine($"  - {f.Location}");
            }
        }

        // For DllImportRule specifically, there should be only 1 finding for shell32
        // (the consolidated call chain), not 2 separate findings
        var dllImportFindings = findings.Where(f =>
            f.RuleId == "DllImportRule" &&
            f.Description.Contains("shell32", StringComparison.OrdinalIgnoreCase)).ToList();

        dllImportFindings.Should().HaveCount(1,
            "Shell32 P/Invoke and its call site should be consolidated into 1 finding, not 2");
    }

    #endregion
}
